#!/bin/bash

stack_file=.git/ladder

_base() {
	git log --format=%H | grep -m1 -f <(git branch | sed 's/^[* ] //' | grep -x -v "$1" | xargs git reflog --format=%H)
}

_down() {
	grep -x -A1 $1 $stack_file | tail -1
}

_go_down() {
	git checkout $(_down `git @`)
}

_go_up() {
	git checkout $(_up)
}

_list() {
	cat $stack_file
}

_rebase() {
	b=`git @`
	git rebase -i --onto `_down $b` `_base $b` $b
}

_up() {
	grep -x -B1 $(git @) $stack_file | head -1
}

# TODO: what if the current branch is not on the stack? some commands like base/down/go/up etc. shouldn't work then
# TODO: completion!
case "$1" in
	append)
		# TODO: handle the case when the file does not exist yet
		# TODO: prevent against re-pushing
		# TODO: accept params - push given branch(es), not the current one
		cat <<-EOF > $stack_file
			$(git @)
			$(cat $stack_file 2>/dev/null)
		EOF
		_list
		;;
	base)
		# TODO: base for the lowest branch?
		_base $(git @)
		;;
	down)
		_down $(git @)
		;;
	edit)
		vim $stack_file
		;;
	go)
		case "$2" in
			# TODO should prevent against accidental cleaning up a path or so
			down) _go_down ;;
			up) _go_up ;;
		esac
		;;
	# TODO add an init command
	list)
		_list
		;;
	rebase)
		_rebase
		;;
	slide-out)
		# TODO What if there's nothing to be slid out?
		base=$(tail -1 $stack_file)
		old=$(tail -2 $stack_file | head -1)
		new=$(tail -3 $stack_file | head -1)
		git rebase -i --onto $base `_base $new` $new && sed -i "/^$old$/d" $stack_file && echo "$new rebased onto $base, $old slid removed from the stack"
		;;
	up)
		_up
		;;
	update)
		# TODO (minor): don't go up if already on top
		_rebase && git push -f && _go_up
		;;
esac

