#!/usr/bin/env python

import getopt
import itertools
import os
import subprocess
import sys


# Core utils

class LadderException(Exception):
    def __init__(self, value):
        self.parameter = value

    def __str__(self):
        return str(self.parameter)


ENDC = '\033[0m'
BOLD = '\033[1m'
UNDERLINE = '\033[4m'
GREEN = '\033[92m'
RED = '\033[91m'


def non_empty_lines(s):
    return filter(None, s.split("\n"))


def excluding(l, s):
    return filter(lambda x: x not in s, l)


def join_branch_names(bs, sep):
    return sep.join("`%s'" % x for x in bs)


def split_array(arr, sep):
    res = []
    start_new = True
    for elem in arr:
        if elem == sep:
            start_new = True
        else:
            if start_new:
                res.append([])
                start_new = False
            res[-1].append(elem)
    return res


def replace_in_array(arr, orig, dst):
    for i in range(len(arr)):
        if arr[i] == orig:
            arr[i] = dst


def expect_no_param(extra_explanation = ''):
    if len(args) == 2:
        raise LadderException("No argument expected for `%s'%s" % (cmd, extra_explanation))


def run_cmd(cmd, *args):
    return subprocess.call([cmd] + list(args))


def popen_cmd(cmd, *args):
    process = subprocess.Popen([cmd] + list(args), stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    stdoutdata, stderrdata = process.communicate()
    return process.returncode, stdoutdata


# Git core

def run_git(git_cmd, *args, **kwargs):
    flat_cmd = " ".join(["git", git_cmd] + list(args))
    if opt_verbose:
        print >> sys.stderr, " ".join(["git", git_cmd] + list(args))
    status = run_cmd("git", git_cmd, *args)
    if not kwargs.get("allow_non_zero") and status != 0:
        raise LadderException("`%s' returned %i" % (flat_cmd, status))
    return status


def popen_git(git_cmd, *args):
    flat_cmd = " ".join(["git", git_cmd] + list(args))
    if opt_verbose:
        print >> sys.stderr, flat_cmd
    status, stdout = popen_cmd("git", git_cmd, *args)
    if status != 0:
        raise LadderException("`%s' returned %i" % (flat_cmd, status))
    return stdout


# Ladder manipulation

def expect_in_ladder(b):
    if b not in all_branches:
        raise LadderException("Branch `%s' does not exist in the ladder. "
                              "Use `git ladder push %s` or `git ladder edit`" % (b, b))


def read_ladder():
    global ladder_file, indent, all_branches, down_branches, up_branch, roots

    try:
        git_root = root_dir()
    except LadderException:
        raise LadderException("Not a git repository")

    ladder_file = os.path.join(git_root, ".git", "ladder")
    if not os.path.exists(ladder_file):
        open(ladder_file, 'w').close()

    with open(ladder_file) as f:
        ldr = [l.rstrip() for l in f.readlines() if not l.isspace()]

    all_branches = []
    down_branches = {}
    up_branch = {}
    indent = None
    roots = []
    at_depth = {}
    
    # TODO: validation!
    for l in ldr:
        pfx = "".join(itertools.takewhile(str.isspace, l))
        if pfx and not indent:
            indent = pfx
        depth = len(pfx) / len(indent) if pfx else 0

        b = l.strip()
        all_branches += [b]
        at_depth[depth] = b
        if depth:
            p = at_depth[depth - 1]
            up_branch[b] = p
            if p in down_branches:
                down_branches[p] += [b]
            else:
                down_branches[p] = [b]
        else:
            roots += [b]

    # TODO: find tops!
    

def render_ladder():
    def render_dfs(u, d):
        print d * indent + u
        for v in down_branches.get(u) or []:
            render_dfs(v, d + 1)

    for r in roots:
        render_dfs(r, 0)


def save_ladder():
    with open(ladder_file, "w") as f:
        f.write("\n".join(render_ladder()))


def up(b):
    expect_in_ladder(b)
    pb = up_branch.get(b)
    return pb if pb else b


def next_branch(b):
    expect_in_ladder(b)
    idx = all_branches.index(b) + 1
    if idx == len(all_branches):
        raise LadderException("Branch `%s' has no successor" % b)
    return all_branches[idx]


def prev_branch(b):
    expect_in_ladder(b)
    idx = all_branches.index(b) - 1
    if idx == -1:
        raise LadderException("Branch `%s' has no predecessor" % b)
    return all_branches[idx]


# TODO!
def top():
    if not trail_tops:
        raise LadderException("Empty ladder. Use `git ladder push [<branch>]` or `git ladder edit`")
    elif len(trail_tops) == 1:
        return trail_tops[0]
    else:
        raise LadderException("Multiple trails, ambiguous trail top: " + join_branch_names(trail_tops, " or "))


def down(b):
    expect_in_ladder(b)
    nb = down_branches.get(b)
    if not nb or len(nb) == 0:
        return b
    elif len(nb) == 1:
        return nb[0]
    else:
        bs = "".join("[%i] %s\n" % (idx + 1, br) for br, idx in zip(nb, range(len(nb))))
        msg = bs + "Specify down-branch or hit <return> to skip: "
        try:
            idx = int(raw_input(msg)) - 1
        except ValueError:
            sys.exit(1)
        if idx not in range(len(nb)):
            raise LadderException("Invalid index: %i" % (idx + 1))
        return nb[idx]


# TODO set default! maybe prev branch, not trail top
def push(b):
    global trail_tops

    if b in all_branches:
        raise LadderException("Branch `%s' already exists in the ladder" % b)

    onto = opt_onto
    if onto:
        expect_in_ladder(onto)
    if not trail_tops:
        trail_tops = [b]
        return

    if not onto:
        if len(trail_tops) > 1:
            raise LadderException("Multiple trail tops, ambiguous push destination: %s.\nSpecify the push destination "
                                  "with `--onto'." % join_branch_names(trail_tops, " or "))
        onto = trail_tops[0]
    if onto in trail_tops:
        replace_in_array(trail_tops, onto, b)
    else:
        trail_tops.append(b)
    up_branch[b] = onto
    if onto in down_branches:
        down_branches[onto].append(b)
    else:
        down_branches[onto] = [b]
    save_ladder()


# Git/shell commands impl

def edit():
    return run_cmd(os.environ.get("EDITOR") or "vim", ladder_file)


def root_dir():
    return popen_git("rev-parse", "--show-toplevel").strip()


def sha_by_revision(rev):
    try:
        return popen_git("rev-parse", "--verify", "--quiet", rev)
    except LadderException:
        return None


def branch_by_revision(rev):
    try:
        return popen_git("rev-parse", "--abbrev-ref", rev).strip()
    except LadderException:
        return None


# TODO what if not on any branch? capture this case!
def head():
    return popen_git("symbolic-ref", "--short", "--quiet", "HEAD").strip()


def log(branch):
    return non_empty_lines(popen_git("log", "--format=%H", branch, "--"))


def reflog(b):
    # %H - full hash
    # %gs - reflog subject
    return [entry.split("|") for entry in non_empty_lines(popen_git("reflog", "--format=%H|%gs", b, "--"))]


def base(branch):
    expect_in_ladder(branch)
    log_this_branch = log(branch)
    other_branches = excluding(branches(), [branch])
    reflogs_other_branches = sum(map(reflog, other_branches), [])
    reflogs_other_branches_no_create = set(h for (h, gs) in reflogs_other_branches if not (
                gs.startswith("branch: Created") or gs.startswith("branch: Reset to " + branch)))
    for h in log_this_branch:
        if h in reflogs_other_branches_no_create:
            return h
    raise LadderException("Cannot find base for branch `%s'" % branch)


def branches():
    return map(lambda b: b[2:], non_empty_lines(popen_git("branch")))


def go(branch):
    run_git("checkout", "--quiet", branch, "--")


def rebase(branch, base_commit):
    run_git("rebase", "--interactive", "--onto", up(branch), base_commit, branch)


def squash(branch, base_commit):
    run_git("rebase", "--interactive", "--onto", base_commit, base_commit, branch)


def diff_base(branch):
    run_git("diff", base(branch), branch, *((["--stat"] if opt_stat else []) + ["--"]))


def prune():
    to_prune = excluding(branches(), all_branches)
    if to_prune:
        if not opt_force:
            bs = ", ".join(map(lambda s: "`%s'" % s, to_prune))
            msg = "This will remove the following branches: %s; continue? [y/n] " % bs
            if raw_input(msg).lower() not in ('y', 'yes'):
                return
        opt_delete = "-D" if opt_force else "-d"
        run_git("branch", opt_delete, *to_prune)
    else:
        print >> sys.stderr, "No branches to remove"


def slide_out(b):
    expect_in_ladder(b)
    u = up_branch.get(b)
    if not u:
        raise LadderException("No up-branch defined for `%s', cannot slide out" % b)
    dbs = down_branches.get(b)
    if not dbs or len(dbs) == 0:
        raise LadderException("No down-branch defined for `%s', cannot slide out" % b)
    elif len(dbs) > 1:
        flat_dbs = join_branch_names(dbs, ", ")
        raise LadderException("Multiple down-branches defined for `%s': %s; cannot slide out" % (b, flat_dbs))
    d = dbs[0]
    go(d)
    up_branch[d] = up_branch[b]
    up_branch[b] = None
    down_branches[u] = down_branches[b]
    down_branches[b] = None
    save_ladder()
    rebase(d, base(d))
    print "Note: branch " + b + " not removed. You can now decide to remove it manually."


def check_needs_sync_with_upstream(b):
    b_sha = sha_by_revision(b)
    if not b_sha:
        raise LadderException("Branch `%s' does not exist" % b)
    b_origin_sha = sha_by_revision((opt_remote or "origin") + "/" + b)
    if not b_origin_sha:
        return False
    return b_sha != b_origin_sha


def status():
    dfs_res = []

    def dfs(u, pfx):
        dfs_res.append((u, pfx))
        if down_branches.get(u):
            for (v, nv) in zip(down_branches[u][:-1], down_branches[u][1:]):
                dfs(v, pfx + [nv])
            dfs(down_branches[u][-1], pfx + [None])

    for u in roots:
        dfs(u, [])

    needs_sync_with_down = {}
    needs_sync_with_upstream = {}
    for b, pfx in dfs_res:
        if b in up_branch:
            s = run_git("merge-base", "--is-ancestor", up_branch[b], b, allow_non_zero=True)
            needs_sync_with_down[b] = s != 0
        needs_sync_with_upstream[b] = check_needs_sync_with_upstream(b)

    def print_line_prefix(suffix):
        for p in pfx[:-1]:
            if not p:
                sys.stdout.write("  ")
            else:
                sys.stdout.write((RED if needs_sync_with_down[p] else GREEN) + "| " + ENDC)
        sys.stdout.write((RED if needs_sync_with_down[b] else GREEN) + suffix + ENDC)

    h = head()
    for b, pfx in dfs_res:
        current = UNDERLINE + b + ENDC if b == h else b
        if b in up_branch:
            sys.stdout.write("  ")
            print_line_prefix("| ")
            print
            sys.stdout.write("  ")
            print_line_prefix("o-")
        else:
            if b != dfs_res[0][0]:
                print
            sys.stdout.write("  ")
        print "%s%s%s%s" % (BOLD, current, ENDC, RED + " (out of sync with " + (opt_remote or "origin") + ")" + ENDC if needs_sync_with_upstream[b] else "")


def update():
    h = head()
    b = opt_base or base(h)
    rebase(h, b)

    opt_push_force = ["--force"] if opt_force else []
    run_git("push", *opt_push_force)


# Main

# TODO!!! define help in keys
def usage(cmd = None):
    cmd_docs = {
        "base": "",
        "diff-base": "",
        "down": "",
        "edit": "",
        "go": "",
        "help": "",
        "next": "",
        "path": "",
        "prev": "",
        "prune": "",
        "push": "",
        "rebase": "",
        "slide-out": "",
        "squash": "",
        "status": "",
        "top": "",
        "up": "",
        "update": ""
    }
    # TODO!
    print >> sys.stderr, "Usage: git ladder <command> [argument]"


try:
    opts, args = getopt.gnu_getopt(sys.argv[1:], "b:fho:r:sv", ['base=', 'force', 'help', 'onto=', 'remote=', 'stat', 'verbose'])

    opt_base = None
    opt_force = False
    opt_onto = None
    opt_remote = None
    opt_stat = False
    opt_verbose = False

    for opt, arg in opts:
        if opt in ("-b", "--base"):
            opt_base = arg
        elif opt in ("-f", "--force"):
            opt_force = True
        elif opt in ("-h", "--help"):
            usage(args[0] if len(args) >= 1 else None)
            sys.exit()
        elif opt in ("-o", "--onto"):
            opt_onto = arg
        elif opt in ("-r", "--remote"):
            opt_remote = arg
        elif opt in ("-s", "--stat"):
            opt_stat = True
        elif opt in ("-v", "--verbose"):
            opt_verbose = True
        else:
            raise LadderException("Unknown option: `%s'" % opt)

    if len(args) not in (1, 2):
        usage()
        sys.exit(2)
    cmd = args[0]
    param = args[1] if len(args) == 2 else None

    read_ladder()

    if cmd == "base":
        print base(param or head())
    elif cmd in ("db", "diff-base"):
        diff_base(param or head())
    elif cmd == "down":
        #process_ladder()
        print down(param or head())
    elif cmd in ("e", "edit"):
        expect_no_param()
        edit()
    elif cmd in ("g", "go"):
        #process_ladder()
        h = head()
        if param in ("d", "down"):
            dest = down(h)
        elif param in ("n", "next"):
            dest = next_branch(h)
        elif param in ("p", "prev"):
            dest = prev_branch(h)
        elif param in ("t", "top"):
            dest = top()
        elif param in ("u", "up"):
            dest = up(h)
        else:
            raise LadderException("Usage: git ladder go <d[own]|n[ext]|p[rev]|t[op]|u[p]>")
        if h != dest:
            go(dest)
    elif cmd == "help":
        usage(param)
    elif cmd == "next":
        #process_ladder()
        print next_branch(param or head())
    elif cmd == "path":
        print ladder_file
    elif cmd == "prev":
        #process_ladder()
        print prev_branch(param or head())
    elif cmd == "prune":
        expect_no_param()
        prune()
    elif cmd == "push":
        #process_ladder()
        push(param or head())
    elif cmd == "rebase":
        expect_no_param(". Use `-b` or `--base` to specify the base commit")
        #process_ladder()
        h = head()
        rebase(h, opt_base or base(h))
    elif cmd == "slide-out":
        #process_ladder()
        slide_out(param or head())
    elif cmd == "squash":
        expect_no_param(". Use `-b` or `--base` to specify the base commit")
        #process_ladder()
        h = head()
        squash(h, opt_base or base(h))
    elif cmd in ("s", "status"):
        expect_no_param()
        #process_ladder()
        status()
    elif cmd == "top":
        expect_no_param()
        #process_ladder()
        print top()
    elif cmd == "up":
        #process_ladder()
        print up(param or head())
    elif cmd == "update":
        expect_no_param(".\nUse `-b` or `--base` to specify the base commit.")
        #process_ladder()
        update()
    else:
        usage()
        raise LadderException("Unknown command: `%s'" % cmd)
except LadderException as e:
    print >> sys.stderr, str(e)
    sys.exit(1)
