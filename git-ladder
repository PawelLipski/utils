#!/usr/bin/env python

import getopt
import os
import subprocess
import sys


# Core utils

class LadderException(Exception):
    def __init__(self, value):
        self.parameter = value

    def __str__(self):
        return str(self.parameter)


def non_empty_lines(s):
    return filter(None, s.split("\n"))


def excluding(l, s):
    return filter(lambda x: x not in s, l)


def split_array(arr, sep):
    res = []
    start_new = True
    for elem in arr:
        if elem == sep:
            start_new = True
        else:
            if start_new:
                res.append([])
                start_new = False
            res[-1].append(elem)
    return res


def replace_in_array(arr, orig, dst):
    for i in range(len(arr)):
        if arr[i] == orig:
            arr[i] = dst


def expect_no_param(extra_explanation = ''):
    if len(args) == 2:
        raise LadderException("No argument expected for `%s'%s" % (cmd, extra_explanation))


def run_cmd(cmd, *args):
    return subprocess.call([cmd] + list(args))


def popen_cmd(cmd, *args):
    process = subprocess.Popen([cmd] + list(args), stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    stdoutdata, stderrdata = process.communicate()
    return process.returncode, stdoutdata


# Git core

def run_git(git_cmd, *args):
    flat_cmd = " ".join(["git", git_cmd] + list(args))
    if opt_verbose:
        print >> sys.stderr, " ".join(["git", git_cmd] + list(args))
    status = run_cmd("git", git_cmd, *args)
    if status != 0:
        raise LadderException("`%s' returned %i" % (flat_cmd, status))


def popen_git(git_cmd, *args):
    flat_cmd = " ".join(["git", git_cmd] + list(args))
    if opt_verbose:
        print >> sys.stderr, flat_cmd
    status, stdout = popen_cmd("git", git_cmd, *args)
    if status != 0:
        raise LadderException("`%s' returned %i" % (flat_cmd, status))
    return stdout


# Ladder manipulation

def expect_in_ladder(b):
    if b not in all_bs:
        raise LadderException("Branch `%s' does not exist in the ladder. "
                              "Use `git ladder push %s` or `git ladder edit`" % (b, b))


def read_ladder():
    global ladder_file, trails, all_bs

    try:
        root = root_dir()
    except LadderException:
        raise LadderException("Not a git repository")

    ladder_file = os.path.join(root, ".git", "ladder")
    if not os.path.exists(ladder_file):
        open(ladder_file, 'w').close()

    with open(ladder_file, "r") as f:
        ldr = map(lambda l: l.strip(), f.readlines())
    trails = split_array(ldr, '')
    all_bs = set(sum(trails, []))


def process_ladder():
    global trail_tops, prev, nexts

    prev = {}
    for t in trails:
        pairs = zip(t[:-1], t[1:])
        for b, p in pairs:
            if b in prev and prev[b] != p:
                raise LadderException("Invalid ladder structure: `%s' first placed on the top of `%s' and later on "
                                      "the top of `%s'. Consider fixing the ladder file manually with "
                                      "`git ladder edit`" % (b, prev[b], p))
            prev[b] = p

    nexts = {}
    for b, p in prev.items():
        if p in nexts:
            nexts[p].append(b)
        else:
            nexts[p] = [b]

    trail_tops = excluding(all_bs, nexts.keys())

    visited = set()
    for b in all_bs:
        if b not in visited:
            i = b
            path = [b]
            while True:
                p = prev.get(i)
                if not p: break
                if p in path:
                    cycle = path[path.index(p):]
                    flat_cycle = " -> ".join(map(lambda x: "`%s'" % x, cycle + [p]))
                    raise LadderException("Invalid ladder structure: found a cycle %s. Consider fixing the ladder "
                                          "file manually with `git ladder edit`" % flat_cycle)
                elif p in visited:
                    break
                path += [p]
                visited.add(p)
                i = p


def render_ladder():
    rendered = set()
    res = []
    first = True
    for tt in trail_tops:
        if first:
            first = False
        else:
            res.append('')

        while True:
            res.append(tt)
            if tt in rendered: break
            rendered.add(tt)
            p = prev.get(tt)
            if not p: break
            tt = p
    return res


def save_ladder():
    with open(ladder_file, "w") as f:
        f.write("\n".join(render_ladder()))


def down(b):
    expect_in_ladder(b)
    pb = prev.get(b)
    return pb if pb else b


def top():
    if not trail_tops:
        raise LadderException("Empty ladder. Use `git ladder push [<branch>]` or `git ladder edit`")
    elif len(trail_tops) == 1:
        return trail_tops[0]
    else:
        raise LadderException("Multiple trails, ambiguous trail top: %s" %
                              " or ".join(map(lambda s: "`%s'" %s, trail_tops)))


def up(b):
    expect_in_ladder(b)
    nb = nexts.get(b)
    if not nb or len(nb) == 0:
        return b
    elif len(nb) == 1:
        return nb[0]
    else:
        raise LadderException("Ambiguous up branch for `%s': %s" % (b, " or ".join(map(lambda s: "`%s'" %s, nb))))


def push(b):
    global trail_tops

    if b in all_bs:
        raise LadderException("Branch `%s' already exists in the ladder" % b)

    onto = opt_onto
    if onto:
        expect_in_ladder(onto)
    if not trail_tops:
        trail_tops = [b]
        return

    if not onto:
        if len(trail_tops) > 1:
            raise LadderException("Multiple trails, ambiguous push destination:"
                                  "%s" % " or ".join(map(lambda s: "`%s'" % s, trail_tops)))
        onto = trail_tops[0]
    if onto in trail_tops:
        replace_in_array(trail_tops, onto, b)
    else:
        trail_tops.append(b)
    prev[b] = onto
    if onto in nexts:
        nexts[onto].append(b)
    else:
        nexts[onto] = [b]
    save_ladder()


# Git/shell commands impl

def edit():
    return run_cmd(os.environ.get("EDITOR") or "vim", ladder_file)


def root_dir():
    return popen_git("rev-parse", "--show-toplevel").strip()


def head():
    return popen_git("symbolic-ref", "--short", "--quiet", "HEAD").strip()


def log(branch):
    return non_empty_lines(popen_git("log", "--format=%H", branch, "--"))


def reflog(bs):
    # %H - full hash
    # %gs - reflog subject
    return [entry.split("|") for entry in non_empty_lines(popen_git("reflog", "--format=%H|%gs", *(bs + ["--"])))]


def base(branch):
    expect_in_ladder(branch)
    log_this_branch = log(branch)
    other_branches = excluding(branches(), [branch])
    reflogs_other_branches = reflog(other_branches)
    reflogs_other_branches_no_create = set(h for (h, gs) in reflogs_other_branches if not (
                gs.startswith("branch: Created") or gs.startswith("branch: Reset to " + branch)))
    for h in log_this_branch:
        if h in reflogs_other_branches_no_create:
            return h
    raise LadderException("Cannot find base for branch `%s'" % branch)


def branches():
    return map(lambda b: b[2:], non_empty_lines(popen_git("branch")))


def go(branch):
    run_git("checkout", "--quiet", branch, "--")


def rebase(branch, base_commit):
    run_git("rebase", "--interactive", "--onto", down(branch), base_commit, branch)


def diff_base(branch):
    run_git("diff", base(branch), branch, "--")


def prune():
    to_prune = excluding(branches(), all_bs)
    if to_prune:
        if not opt_force:
            bs = ", ".join(map(lambda s: "`%s'" % s, to_prune))
            msg = "This will remove the following branches: %s; continue? [y/n] " % bs
            if raw_input(msg).lower() not in ('y', 'yes'):
                return
        opt_delete = "-D" if opt_force else "-d"
        run_git("branch", opt_delete, *to_prune)
    else:
        print >> sys.stderr, "No branches to remove"


def slide_out(b):
    expect_in_ladder(b)
    d = prev.get(b)
    if not d:
        raise LadderException("No down branch defined for `%s', cannot slide out" % b)
    u_s = nexts.get(b)
    if not u_s or len(u_s) == 0:
        raise LadderException("No up branch defined for `%s', cannot slide out" % b)
    elif len(u_s) > 1:
        flat_u_s = ", ".join(map(lambda s: "`%s'" % s, u_s))
        raise LadderException("Multiple up branches defined for `%s': %s; cannot slide out" % (b, flat_u_s))
    u = u_s[0]
    go(u)
    prev[u] = prev[b]
    prev[b] = None
    nexts[d] = nexts[b]
    nexts[b] = None
    save_ladder()
    rebase(u, base(u))
    print "Note: branch " + b + " not removed. You can now decide to remove it manually."


def update():
    h = head()
    b = opt_base or base(h)
    rebase(h, b)

    opt_push_force = ["--force"] if opt_force else []
    run_git("push", *opt_push_force)

    go(up(h))


# Main

# TODO!!! define help in keys
def usage(cmd = None):
    cmd_docs = {
        "base": "",
        "diff-base": "",
        "down": "",
        "edit": "",
        "go": "",
        "help": "",
        "list": "",
        "path": "",
        "prune": "",
        "push": "",
        "rebase": "",
        "slide-out": "",
        "top": "",
        "up": "",
        "update": ""
    }
    # TODO!
    print >> sys.stderr, "Usage: git ladder <command> [argument]"


try:
    opts, args = getopt.gnu_getopt(sys.argv[1:], "b:fho:v", ['base=', 'force', 'help', 'onto=', 'verbose'])

    opt_base = None
    opt_force = False
    opt_onto = None
    opt_verbose = False

    for opt, arg in opts:
        if opt in ("-b", "--base"):
            opt_base = arg
        elif opt in ("-f", "--force"):
            opt_force = True
        elif opt in ("-h", "--help"):
            usage(args[0] if len(args) >= 1 else None)
            sys.exit()
        elif opt in ("-o", "--onto"):
            opt_onto = arg
        elif opt in ("-v", "--verbose"):
            opt_verbose = True
        else:
            raise LadderException("Unknown option: `%s'" % opt)

    if len(args) not in (1, 2):
        usage()
        sys.exit(2)
    cmd = args[0]
    param = args[1] if len(args) == 2 else None

    read_ladder()

    if cmd == "base":
        print base(param or head())
    elif cmd == "diff-base":
        diff_base(param or head())
    elif cmd == "down":
        process_ladder()
        print down(param or head())
    elif cmd in ("e", "edit"):
        expect_no_param()
        edit()
    elif cmd in ("g", "go"):
        process_ladder()
        h = head()
        if param in ("d", "down"):
            dest = down(h)
        elif param in ("t", "top"):
            dest = top()
        elif param in ("u", "up"):
            dest = up(h)
        else:
            raise LadderException("Usage: git ladder go <d[own]|t[op]|u[p]>")
        if h != dest:
            go(dest)
    elif cmd == "help":
        usage(param)
    elif cmd in ("l", "list"):
        expect_no_param()
        process_ladder()
        print "\n".join(render_ladder())
    elif cmd == "path":
        print ladder_file
    elif cmd == "prune":
        expect_no_param()
        prune()
    elif cmd in ("p", "push"):
        process_ladder()
        push(param or head())
    elif cmd == "rebase":
        expect_no_param(". Use `-b` or `--base` to specify the base commit")
        process_ladder()
        h = head()
        rebase(h, opt_base or base(h))
    elif cmd == "slide-out":
        process_ladder()
        slide_out(param or head())
    elif cmd == "top":
        expect_no_param()
        process_ladder()
        print top()
    elif cmd == "up":
        process_ladder()
        print up(param or head())
    elif cmd == "update":
        expect_no_param(". Use `-b` or `--base` to specify the base commit")
        process_ladder()
        update()
    else:
        usage()
        raise LadderException("Unknown command: `%s'" % cmd)
except Exception as e:
    print >> sys.stderr, str(e)
    sys.exit(1)
