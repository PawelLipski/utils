#!/usr/bin/env python

import getopt
import itertools
import os
import subprocess
import sys
import textwrap


# Core utils

class LadderException(Exception):
    def __init__(self, value):
        self.parameter = value

    def __str__(self):
        return str(self.parameter)


ENDC = '\033[0m'
BOLD = '\033[1m'
UNDERLINE = '\033[4m'
GREEN = '\033[92m'
RED = '\033[91m'


def non_empty_lines(s):
    return filter(None, s.split("\n"))


def excluding(l, s):
    return filter(lambda x: x not in s, l)


def join_branch_names(bs, sep):
    return sep.join("`%s'" % x for x in bs)


def split_array(arr, sep):
    res = []
    start_new = True
    for elem in arr:
        if elem == sep:
            start_new = True
        else:
            if start_new:
                res.append([])
                start_new = False
            res[-1].append(elem)
    return res


def replace_in_array(arr, orig, dst):
    for i in range(len(arr)):
        if arr[i] == orig:
            arr[i] = dst


def pick(choices, name):
    xs = "".join("[%i] %s\n" % (idx + 1, x) for x, idx in zip(choices, range(len(choices))))
    msg = xs + "Specify " + name + " or hit <return> to skip: "
    try:
        idx = int(raw_input(msg)) - 1
    except ValueError:
        sys.exit(1)
    if idx not in range(len(choices)):
        raise LadderException("Invalid index: %i" % (idx + 1))
    return choices[idx]


def run_cmd(cmd, *args):
    return subprocess.call([cmd] + list(args))


def popen_cmd(cmd, *args):
    process = subprocess.Popen([cmd] + list(args), stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    stdoutdata, stderrdata = process.communicate()
    return process.returncode, stdoutdata


# Git core

def run_git(git_cmd, *args, **kwargs):
    flat_cmd = " ".join(["git", git_cmd] + list(args))
    if opt_verbose:
        print >> sys.stderr, " ".join(["git", git_cmd] + list(args))
    status = run_cmd("git", git_cmd, *args)
    if not kwargs.get("allow_non_zero") and status != 0:
        raise LadderException("`%s' returned %i" % (flat_cmd, status))
    return status


def popen_git(git_cmd, *args):
    flat_cmd = " ".join(["git", git_cmd] + list(args))
    if opt_verbose:
        print >> sys.stderr, flat_cmd
    status, stdout = popen_cmd("git", git_cmd, *args)
    if status != 0:
        raise LadderException("`%s' returned %i" % (flat_cmd, status))
    return stdout


# Ladder manipulation

def expect_in_ladder(b):
    if b not in all_branches:
        raise LadderException("Branch `%s' not found in the ladder. "
                              "Use `git ladder push %s' or `git ladder edit'" % (b, b))


def read_ladder():
    global ladder_file, indent, all_branches, down_branches, up_branch, roots

    with open(ladder_file) as f:
        ldr = [l.rstrip() for l in f.readlines() if not l.isspace()]

    all_branches = []
    down_branches = {}
    up_branch = {}
    indent = None
    roots = []
    at_depth = {}
    last_depth = -1
    hint = "Edit the ladder file manually with `git ladder edit'"

    for idx, l in enumerate(ldr):
        pfx = "".join(itertools.takewhile(str.isspace, l))
        if pfx and not indent:
            indent = pfx

        b = l.strip()
        if b in all_branches:
            raise LadderException("%s, line %i: branch `%s' re-appears in the ladder. %s" %
                                  (ladder_file, idx + 1, b, hint))
        all_branches += [b]

        depth = len(pfx) / len(indent) if pfx else 0
        if depth > last_depth + 1:
            raise LadderException("%s, line %i: too much indent for the branch `%s'. %s" %
                                  (ladder_file, idx + 1, b, hint))
        last_depth = depth

        at_depth[depth] = b
        if depth:
            p = at_depth[depth - 1]
            up_branch[b] = p
            if p in down_branches:
                down_branches[p] += [b]
            else:
                down_branches[p] = [b]
        else:
            roots += [b]


def render_ladder():
    def render_dfs(u, d):
        res = [d * indent + u]
        for v in down_branches.get(u) or []:
            res += render_dfs(v, d + 1)
        return res

    total = []
    for r in roots:
        total += render_dfs(r, 0)
    return total


def save_ladder():
    with open(ladder_file, "w") as f:
        f.write("\n".join(render_ladder()))


def down(b, pick_mode=True):
    expect_in_ladder(b)
    dbs = down_branches.get(b)
    if not dbs or len(dbs) == 0:
        raise LadderException("Branch `%s' has no down branch" % b)
    elif len(dbs) == 1:
        return dbs[0]
    elif pick_mode:
        return pick(dbs, "down branch")
    else:
        return "\n".join(dbs)


def next_branch(b):
    expect_in_ladder(b)
    idx = all_branches.index(b) + 1
    if idx == len(all_branches):
        raise LadderException("Branch `%s' has no successor" % b)
    return all_branches[idx]


def prev_branch(b):
    expect_in_ladder(b)
    idx = all_branches.index(b) - 1
    if idx == -1:
        raise LadderException("Branch `%s' has no predecessor" % b)
    return all_branches[idx]


def root_branch(b):
    expect_in_ladder(b)
    u = up_branch.get(b)
    if not u:
        raise LadderException("Branch `%s' is already a root" % b)
    while u:
        b = u
        u = up_branch.get(b)
    return b


def up(b):
    expect_in_ladder(b)
    pb = up_branch.get(b)
    if pb:
        return pb
    else:
        raise LadderException("Branch `%s' has no up branch" % b)


def push(b):
    global roots

    if b in all_branches:
        raise LadderException("Branch `%s' already exists in the ladder" % b)

    if not sha_by_revision(b):
        raise LadderException("Branch `%s' does not exist" % b)

    onto = opt_onto
    if onto:
        expect_in_ladder(onto)
    if not roots:
        roots = [b]
        return

    if not onto:
        try:
            h = head()
        except LadderException:
            h = None
        if b != h:
            onto = h
        else:
            raise LadderException("Specify the branch to push `%s' onto with `--onto'" % b)

    up_branch[b] = onto
    if onto in down_branches:
        down_branches[onto].append(b)
    else:
        down_branches[onto] = [b]
    save_ladder()


# Git/shell commands impl

def edit():
    return run_cmd(os.environ.get("EDITOR") or "vim", ladder_file)


def root_dir():
    return popen_git("rev-parse", "--show-toplevel").strip()


def sha_by_revision(rev):
    try:
        return popen_git("rev-parse", "--verify", "--quiet", rev)
    except LadderException:
        return None


def branch_by_revision(rev):
    try:
        return popen_git("rev-parse", "--abbrev-ref", rev).strip()
    except LadderException:
        return None


def head():
    try:
        return popen_git("symbolic-ref", "--short", "--quiet", "HEAD").strip()
    except LadderException:
        raise LadderException("Not currently on any branch")


def log(branch):
    return non_empty_lines(popen_git("log", "--format=%H", branch, "--"))


def reflog(b):
    # %H - full hash
    # %gs - reflog subject
    return [entry.split("|") for entry in non_empty_lines(popen_git("reflog", "--format=%H|%gs", b, "--"))]


def base(branch):
    expect_in_ladder(branch)
    log_this_branch = log(branch)
    other_branches = excluding(branches(), [branch])
    reflogs_other_branches = sum(map(reflog, other_branches), [])
    reflogs_other_branches_no_create = set(h for (h, gs) in reflogs_other_branches if not (
                gs.startswith("branch: Created") or gs.startswith("branch: Reset to " + branch)))
    for h in log_this_branch:
        if h in reflogs_other_branches_no_create:
            return h
    raise LadderException("Cannot find base for branch `%s'" % branch)


def branches():
    return map(lambda b: b[2:], non_empty_lines(popen_git("branch")))


def go(branch):
    run_git("checkout", "--quiet", branch, "--")


def update(branch, base_commit):
    run_git("rebase", "--interactive", "--onto", up(branch), base_commit, branch)


def squash(branch, base_commit):
    run_git("rebase", "--interactive", "--onto", base_commit, base_commit, branch)


def diff_base(branch):
    run_git("diff", *((["--stat"] if opt_stat else []) + [base(branch), "--"]))


def prune():
    to_prune = excluding(branches(), all_branches)
    if to_prune:
        if not opt_force:
            bs = ", ".join(map(lambda s: "`%s'" % s, to_prune))
            msg = "This will remove the following branches: %s; continue? [y/n] " % bs
            if raw_input(msg).lower() not in ('y', 'yes'):
                return
        opt_delete = "-D" if opt_force else "-d"
        run_git("branch", opt_delete, *to_prune)
    else:
        print >> sys.stderr, "No branches to remove"


def slide_out(b):
    expect_in_ladder(b)
    u = up_branch.get(b)
    if not u:
        raise LadderException("No up-branch defined for `%s', cannot slide out" % b)
    dbs = down_branches.get(b)
    if not dbs or len(dbs) == 0:
        raise LadderException("No down-branch defined for `%s', cannot slide out" % b)
    elif len(dbs) > 1:
        flat_dbs = join_branch_names(dbs, ", ")
        raise LadderException("Multiple down-branches defined for `%s': %s; cannot slide out" % (b, flat_dbs))
    d = dbs[0]
    go(d)
    up_branch[d] = up_branch[b]
    up_branch[b] = None
    down_branches[u] = down_branches[b]
    down_branches[b] = None
    save_ladder()
    update(d, opt_down_base or base(d))
    print "Note: branch " + b + " not removed. You can now decide to remove it manually."


def check_needs_sync_with_upstream(b):
    b_sha = sha_by_revision(b)
    if not b_sha:
        raise LadderException("Branch `%s' does not exist" % b)
    b_origin_sha = sha_by_revision((opt_remote or "origin") + "/" + b)
    if not b_origin_sha:
        return False
    return b_sha != b_origin_sha


def status():
    dfs_res = []

    def dfs(u, pfx):
        dfs_res.append((u, pfx))
        if down_branches.get(u):
            for (v, nv) in zip(down_branches[u][:-1], down_branches[u][1:]):
                dfs(v, pfx + [nv])
            dfs(down_branches[u][-1], pfx + [None])

    for u in roots:
        dfs(u, [])

    needs_sync_with_down = {}
    needs_sync_with_upstream = {}
    for b, pfx in dfs_res:
        if b in up_branch:
            s = run_git("merge-base", "--is-ancestor", up_branch[b], b, allow_non_zero=True)
            needs_sync_with_down[b] = s != 0
        needs_sync_with_upstream[b] = check_needs_sync_with_upstream(b)

    def print_line_prefix(suffix):
        sys.stdout.write("  ")
        for p in pfx[:-1]:
            if not p:
                sys.stdout.write("  ")
            else:
                sys.stdout.write((RED if needs_sync_with_down[p] else GREEN) + "| " + ENDC)
        sys.stdout.write((RED if needs_sync_with_down[b] else GREEN) + suffix + ENDC)

    try:
        h = head()
    except LadderException:
        h = None

    for b, pfx in dfs_res:
        current = UNDERLINE + b + ENDC if b == h else b
        if b in up_branch:
            print_line_prefix("| \n")
            print_line_prefix("o-")
        else:
            if b != dfs_res[0][0]:
                print
            sys.stdout.write("  ")
        print "%s%s%s%s" % (BOLD, current, ENDC, RED + " (out of sync with " + (opt_remote or "origin") + ")" + ENDC if needs_sync_with_upstream[b] else "")


# Main

def usage(c=None):
    short_docs = {
        "base": "Print SHA of the base commit of the current branch",
        "diff-base": "Diff current working tree against the base commit of the current branch",
        "down": "Print name(s) of the down branch(es) for the current branch (aka children in the tree)",
        "edit": "Edit the ladder definition file",
        "file": "Print path of the ladder definition file",
        "go": "Checkout the branch relative to the position in ladder, accepts down/next/root/prev/up argument",
        "help": "Print this overview, or print detailed help for a specified command",
        "next": "Print name of the next branch for the current branch",
        "prev": "Print name of the previous branch for the current branch",
        "prune": "Remove all local branches that are not in the ladder",
        "push": "Add a branch into the ladder on the top of the current or other specified branch",
        "root": "Print name of the root branch of the tree where the current branch is located",
        "slide-out": "Slide the branch out from the ladder and rebase its down branch",
        "squash": "Rebase the current branch on the top of its base commit",
        "status": "Print tree-shaped status of branches in the ladder, including info on their sync with up branch and remote",
        "up": "Print name of the up branch for the current branch (aka parent in the tree)",
        "update": "Rebase the current branch on the top of its up branch"
    }
    example = ""
    long_docs = {
        "base": """
            Usage: git ladder base [<branch>]

            Prints the
        """,
        "diff-base": """
            Usage: git ladder diff-base [-b | --base=<base-commit>] [-s | --stat] [<branch>]

        """,
        "down":  """
            Usage: git ladder down [<branch>]

        """,
        "edit": """
            Usage: git ladder edit

        """,
        "file": """
            Usage: git ladder file

        """,
        "go": """
            Usage: git ladder go <direction>
            where <direction> is one of: down, next, prev, root, up

        """,
        "help": """
            Usage: git ladder help [<command>]
        """,
        "next": """
            Usage: git ladder next [<branch>]

        """,
        "prev": """
            Usage: git ladder prev [<branch>]

        """,
        "prune": """
            Usage: git ladder prune [-f|--force]

        """,
        "push": """
            Usage: git ladder push [-o|--onto=<target-branch>] [<branch>]

        """,
        "root": """
            Usage: git ladder root [<branch>]

        """,
        "slide-out": """
            Usage: git ladder slide-out [-d|--down-base=<down-base-commit>] [<branch>]

        """,
        "squash": """
            Usage: git ladder squash [-b|--base=<base-commit>]

        """,
        "status": """
            Usage: git ladder status [-r|--remote=<remote-name>]

        """,
        "up": """
            Usage: git ladder up [<branch>]

        """,
        "update": """
            Usage: git ladder update [-b|--base=<base-commit>]

        """
    }
    groups = [
        ("General commands", ["help"]),
        ("Edit and display the ladder", ["edit", "file", "push", "status"]),
        ("Move across the ladder", ["down", "go", "next", "prev", "root", "up"]),
        ("Determine changes introduced on the branch", ["base", "diff-base"]),
        ("Update history in accordance with the ladder", ["slide-out", "squash", "update"]),
        ("Tidy up git branches", ["prune"])
    ]
    if c and c in short_docs:
        # TODO cmd docs!
        s = short_docs[c]
        l = long_docs[c]
        print >> sys.stderr, "\n%sgit ladder %s%s - %s\n%s" % \
                             (BOLD, c, ENDC, s[:1].lower() + s[1:] if s else '', textwrap.dedent(l))
    else:
        short_usage()
        if c and c not in short_docs:
            print >> sys.stderr, "\nUnknown command: `%s'" % c
        print >> sys.stderr, "\n" + UNDERLINE + "TL;DR tip" + ENDC + ": get familiar with `edit', `status', `push' and `update' commands.\n"
        for hdr, cmds in groups:
            print >> sys.stderr, BOLD + hdr + ENDC + "\n"
            for cm in cmds:
                print >> sys.stderr, "    %s%-12s%s%s" % (BOLD, cm, ENDC, short_docs[cm])
            print >> sys.stderr


def short_usage():
    print >> sys.stderr, "Usage: git ladder [--help] [--verbose] <command> [command-specific options] [command-specific argument]"


def parse_options(in_args, short_opts="", long_opts=[], gnu = True):
    global cmd, opt_base, opt_down_base, opt_force, opt_onto, opt_remote, opt_stat, opt_verbose

    fun = getopt.gnu_getopt if gnu else getopt.getopt
    opts, rest = fun(in_args, short_opts + "hv", long_opts + ['help', 'verbose'])

    for opt, arg in opts:
        if opt in ("-b", "--base"):
            opt_base = arg
        elif opt in ("-d", "--down-base"):
            opt_down_base = arg
        elif opt in ("-f", "--force"):
            opt_force = True
        elif opt in ("-h", "--help"):
            usage(cmd)
            sys.exit()
        elif opt in ("-o", "--onto"):
            opt_onto = arg
        elif opt in ("-r", "--remote"):
            opt_remote = arg
        elif opt in ("-s", "--stat"):
            opt_stat = True
        elif opt in ("-v", "--verbose"):
            opt_verbose = True
    return rest


def expect_no_param(in_args, extra_explanation = ''):
    if len(in_args) == 2:
        raise LadderException("No argument expected for `%s'%s" % (cmd, extra_explanation))


def check_optional_param(in_args):
    if not in_args:
        return None
    elif len(in_args) > 1:
        raise LadderException("`%s' accepts at most one argument" % cmd)
    elif not in_args[0]:
        raise LadderException("Argument to `%s' cannot be empty" % cmd)
    elif in_args[0][0] == "-":
        raise LadderException("option `%s' not recognized" % in_args[0])
    else:
        return in_args[0]


def check_required_param(in_args):
    if not in_args or len(in_args) > 1:
        raise LadderException("`%s' requires exactly one argument" % cmd)
    elif not in_args[0]:
        raise LadderException("Argument to `%s' cannot be empty" % cmd)
    elif in_args[0][0] == "-":
        raise LadderException("option `%s' not recognized" % in_args[0])
    else:
        return in_args[0]


try:
    cmd = None
    opt_base = None
    opt_down_base = None
    opt_force = False
    opt_onto = None
    opt_remote = None
    opt_stat = False
    opt_verbose = False

    all_args = parse_options(sys.argv[1:], gnu=False)
    if not all_args:
        usage()
        sys.exit(2)
    cmd = all_args[0]
    args = all_args[1:]

    try:
        git_root = root_dir()
    except LadderException:
        raise LadderException("Not a git repository")

    ladder_file = os.path.join(git_root, ".git", "ladder")
    if not os.path.exists(ladder_file):
        open(ladder_file, 'w').close()

    if cmd not in ("e", "edit", "file", "help"):
        read_ladder()

    if cmd == "base":
        param = check_optional_param(parse_options(args))
        print base(param or head())
    elif cmd in ("db", "diff-base"):
        param = check_optional_param(parse_options(args, "b:s", ["base=", "stat"]))
        diff_base(param or head())
    elif cmd == "down":
        param = check_optional_param(parse_options(args))
        print down(param or head(), pick_mode=False)
    elif cmd in ("e", "edit"):
        expect_no_param(parse_options(args))
        edit()
    elif cmd == "file":
        expect_no_param(parse_options(args))
        print ladder_file
    elif cmd in ("g", "go"):
        param = check_required_param(parse_options(args))
        h = head()
        if param in ("d", "down"):
            dest = down(h)
        elif param in ("n", "next"):
            dest = next_branch(h)
        elif param in ("p", "prev"):
            dest = prev_branch(h)
        elif param in ("r", "root"):
            dest = root_branch(h)
        elif param in ("u", "up"):
            dest = up(h)
        else:
            raise LadderException("Usage: git ladder go <d[own]|n[ext]|p[rev]|r[oot]|u[p]>")
        if dest != h:
            go(dest)
    elif cmd == "help":
        param = check_optional_param(parse_options(args))
        usage(param)
    elif cmd == "next":
        param = check_optional_param(parse_options(args))
        print next_branch(param or head())
    elif cmd == "prev":
        param = check_optional_param(parse_options(args))
        print prev_branch(param or head())
    elif cmd == "prune":
        expect_no_param(parse_options(args, "f", ["force"]))
        prune()
    elif cmd == "push":
        param = check_optional_param(parse_options(args, "o:", ["onto="]))
        push(param or head())
    elif cmd == "root":
        param = check_optional_param(parse_options(args))
        print root_branch(param or head())
    elif cmd == "slide-out":
        param = check_optional_param(parse_options(args, "d:", ["down-base="]))
        slide_out(param or head())
    elif cmd == "squash":
        args1 = parse_options(args, "b:", ["base="])
        expect_no_param(args1, ". Use `-b' or `--base' to specify the base commit")
        h = head()
        squash(h, opt_base or base(h))
    elif cmd in ("s", "status"):
        expect_no_param(parse_options(args, "r:", ["remote="]))
        status()
    elif cmd == "up":
        param = check_optional_param(parse_options(args))
        print up(param or head())
    elif cmd == "update":
        args1 = parse_options(args, "b:", ["base="])
        expect_no_param(args1, ". Use `-b' or `--base' to specify the base commit")
        h = head()
        update(h, opt_base or base(h))
    else:
        short_usage()
        raise LadderException("\nUnknown command: `%s'. Use `git ladder help' to list possible commands" % cmd)

except LadderException as e:
    print >> sys.stderr, str(e)
    sys.exit(1)
except getopt.GetoptError as e:
    short_usage()
    print >> sys.stderr, str(e)
    sys.exit(2)
