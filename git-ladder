#!/usr/bin/env python

import os
import subprocess
import sys

ladder_file = ".git/ladder"

# Core utils


class LadderException(Exception):
    def __init__(self, value):
        self.parameter = value


def non_empty_lines(s):
    return filter(None, s.split("\n"))


def excluding(l, s):
    return filter(lambda x: x not in s, l)


def split_array(arr, sep):
    res = []
    start_new = True
    for elem in arr:
        if elem == sep:
            start_new = True
        else:
            if start_new:
                res.append([])
                start_new = False
            res[-1].append(elem)
    return res


def replace_in_array(arr, orig, dest):
    for i in range(len(arr)):
        if arr[i] == orig:
            arr[i] = dest


def run_cmd(cmd, *args):
    return subprocess.call([cmd] + list(args)) == 0


def popen_cmd(cmd, *args):
    return subprocess.Popen([cmd] + list(args), stdout=subprocess.PIPE).stdout.read()


# Git core

def run_git(git_cmd, *args):
    print " ".join(["git", git_cmd] + list(args))
    return run_cmd("git", git_cmd, *args)


def popen_git(git_cmd, *args):
    print " ".join(["git", git_cmd] + list(args))
    return popen_cmd("git", git_cmd, *args)


# Ladder manipulation

def read_ladder():
    with open(ladder_file, "r") as f:
        return map(lambda l: l.strip(), f.readlines())


def render_ladder():
    rendered = set()
    res = []
    first = True
    for tt in trail_tops:
        if first:
            first = False
        else:
            res.append('')

        while True:
            res.append(tt)
            if tt in rendered: break
            rendered.add(tt)
            p = prev.get(tt)
            if not p: break
            tt = p
    return res


def save_ladder():
    with open(ladder_file, "w") as f:
        f.write("\n".join(render_ladder()))


def down(b):
    pb = prev.get(b)
    return pb if pb else b


def up(b):
    nb = nexts.get(b)
    if not nb or len(nb) == 0:
        return b
    elif len(nb) == 1:
        return nb[0]
    else:
        raise LadderException("Ambiguous superbranch for `%s': %s" % (b, " or ".join(map(lambda s: "`%s'" %s, nb))))


def push(b, onto=None):
    if not onto: onto = trail_tops[0]
    if onto in trail_tops:
        replace_in_array(trail_tops, onto, b)
    else:
        trail_tops.append(b)
    prev[b] = onto
    if onto in nexts:
        nexts[onto].append(b)
    else:
        nexts[onto] = [b]


# Git/shell commands impl

def edit():
    return run_cmd(os.environ.get("EDITOR") or "vim", ladder_file)


def head():
    return popen_git("symbolic-ref", "--short", "--quiet", "HEAD").strip()


def log(branch):
    return non_empty_lines(popen_git("log", "--format=%H", branch, "--"))


def reflog(bs):
    # %H - full hash
    # %gs - reflog subject
    return [entry.split("|") for entry in non_empty_lines(popen_git("reflog", "--format=%H|%gs", *(bs + ["--"])))]


def base(branch):
    if branch not in all_bs:
        raise LadderException("Branch `%s' does not exist in the ladder" % branch)
    log_this_branch = log(branch)
    other_branches = excluding(branches(), [branch])
    reflogs_other_branches = reflog(other_branches)
    reflogs_other_branches_no_create = set(h for (h, gs) in reflogs_other_branches if not (
                gs.startswith("branch: Created") or gs.startswith("branch: Reset to " + branch)))
    for h in log_this_branch:
        if h in reflogs_other_branches_no_create:
            return h
    raise LadderException("Cannot find base for branch `%s'" % branch)


def branches():
    return map(lambda b: b[2:], non_empty_lines(popen_git("branch")))


def go(branch):
    # TODO: don't go to current branch....
    return run_git("checkout", "--quiet", branch, "--")


def rebase(branch, base_commit):
    return run_git("rebase", "--interactive", "--onto", down(branch), base_commit, branch)


def diff_base(branch):
    return run_git("diff", base(branch), branch, "--")


def prune():
    # TODO: ask to confirm + also mention about `rebase` possibly not working
    to_prune = excluding(branches(), all_bs)
    return run_git("branch", "-d", *to_prune) if to_prune else 0


# Main

# TODO check if ladder file exists
trails = split_array(read_ladder(), '')
trail_tops = map(lambda x: x[0], trails)
prev = {}
for t in trails:
    prev.update(dict(zip(t[:-1], t[1:])))

nexts = {}
for b, p in prev.items():
    if p in nexts:
        nexts[p].append(b)
    else:
        nexts[p] = [b]

all_bs = set(sum(trails, []))


def main():
    try:
        if len(sys.argv) < 2:
            raise LadderException("Usage: git ladder <command> [params]")
        param = sys.argv[2] if len(sys.argv) >= 3 else None

        cmd = sys.argv[1]
        if cmd == "base":
            print base(param or head())
        elif cmd == "diff-base":
            diff_base(param or head())
        elif cmd == "down":
            print down(param or head())
        elif cmd == "edit":
            edit()
        elif cmd == "help":
            # TODO!
            pass
        elif cmd == "go":
            if param == "down":
                go(down(head()))
            elif param == "up":
                go(up(head()))
            else:
                raise LadderException("Usage: git ladder go <down|up>")
        elif cmd == "list":
            print "\n".join(render_ladder())
        elif cmd == "prune":
            # TODO: -f option that would call branch -D
            prune()
        elif cmd == "push":
            b = param or head()
            if b in all_bs:
                raise LadderException("Branch `%s' already exists in the ladder" % b)
            push(b)
            save_ladder()
        elif cmd == "rebase":
            # TODO: parse -b option (or maybe call it differently, like -a for after?)
            h = head()
            rebase(h, param or base(h))
        # elif cmd == "slide-out":
        # TODO: needs some extra checks to implement
        #     # TODO: or sth else if param provided
        #     h = head()
        #     # TODO: handle if multiple superbranches
        #     u = up(h)
        #     go(u)
        #     save_ladder()
        #     rebase(u, base(u))
        #     print "Note: branch " + h + " not removed. You can now decide to remove it manually."
        elif cmd == "up":
            print up(param or head())
        elif cmd == "update":
            h = head()
            b = sys.argv[2] if len(sys.argv) >= 3 else base(h)
            rebase(h, b) and run_git("push", "--force") and go(up(h))
        else:
            # TODO or just call help
            raise LadderException("Unknown command: `%s'. Use `git ladder help` to list possible commands" % cmd)
    except LadderException, e:
        print >> sys.stderr, e.parameter


if __name__ == '__main__':
    main()
