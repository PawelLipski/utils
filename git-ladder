#!/usr/bin/env python

import getopt
import itertools
import os
import subprocess
import sys
import textwrap


# Core utils

class LadderException(Exception):
    def __init__(self, value):
        self.parameter = value

    def __str__(self):
        return str(self.parameter)


ENDC = '\033[0m'
BOLD = '\033[1m'
UNDERLINE = '\033[4m'
GREEN = '\033[92m'
GREY = '\033[37m'
RED = '\033[91m'


def non_empty_lines(s):
    return filter(None, s.split("\n"))


def excluding(l, s):
    return filter(lambda x: x not in s, l)


def join_branch_names(bs, sep):
    return sep.join("`%s'" % x for x in bs)


def split_array(arr, sep):
    res = []
    start_new = True
    for elem in arr:
        if elem == sep:
            start_new = True
        else:
            if start_new:
                res.append([])
                start_new = False
            res[-1].append(elem)
    return res


def replace_in_array(arr, orig, dst):
    for i in range(len(arr)):
        if arr[i] == orig:
            arr[i] = dst


def pick(choices, name):
    xs = "".join("[%i] %s\n" % (idx + 1, x) for x, idx in zip(choices, range(len(choices))))
    msg = xs + "Specify " + name + " or hit <return> to skip: "
    try:
        idx = int(raw_input(msg)) - 1
    except ValueError:
        sys.exit(1)
    if idx not in range(len(choices)):
        raise LadderException("Invalid index: %i" % (idx + 1))
    return choices[idx]


def run_cmd(cmd, *args):
    return subprocess.call([cmd] + list(args))


def popen_cmd(cmd, *args):
    process = subprocess.Popen([cmd] + list(args), stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    stdoutdata, stderrdata = process.communicate()
    return process.returncode, stdoutdata


# Git core

def run_git(git_cmd, *args, **kwargs):
    flat_cmd = " ".join(["git", git_cmd] + list(args))
    if opt_verbose:
        print >> sys.stderr, " ".join(["git", git_cmd] + list(args))
    status = run_cmd("git", git_cmd, *args)
    if not kwargs.get("allow_non_zero") and status != 0:
        raise LadderException("`%s' returned %i" % (flat_cmd, status))
    return status


def popen_git(git_cmd, *args):
    flat_cmd = " ".join(["git", git_cmd] + list(args))
    if opt_verbose:
        print >> sys.stderr, flat_cmd
    status, stdout = popen_cmd("git", git_cmd, *args)
    if status != 0:
        raise LadderException("`%s' returned %i" % (flat_cmd, status))
    return stdout


# Ladder manipulation

def expect_in_ladder(b):
    if b not in all_branches:
        raise LadderException("Branch `%s' not found in the ladder. "
                              "Use `git ladder add %s' or `git ladder edit'" % (b, b))


def read_ladder():
    global ladder_file, indent, all_branches, down_branches, up_branch, roots

    with open(ladder_file) as f:
        ldr = [l.rstrip() for l in f.readlines() if not l.isspace()]

    all_branches = []
    down_branches = {}
    up_branch = {}
    indent = None
    roots = []
    at_depth = {}
    last_depth = -1
    hint = "Edit the ladder file manually with `git ladder edit'"

    for idx, l in enumerate(ldr):
        pfx = "".join(itertools.takewhile(str.isspace, l))
        if pfx and not indent:
            indent = pfx

        b = l.strip()
        if b in all_branches:
            raise LadderException("%s, line %i: branch `%s' re-appears in the ladder. %s" %
                                  (ladder_file, idx + 1, b, hint))
        all_branches += [b]

        depth = len(pfx) / len(indent) if pfx else 0
        if depth > last_depth + 1:
            raise LadderException("%s, line %i: too much indent for the branch `%s'. %s" %
                                  (ladder_file, idx + 1, b, hint))
        last_depth = depth

        at_depth[depth] = b
        if depth:
            p = at_depth[depth - 1]
            up_branch[b] = p
            if p in down_branches:
                down_branches[p] += [b]
            else:
                down_branches[p] = [b]
        else:
            roots += [b]


def render_ladder():
    def render_dfs(u, d):
        res = [d * indent + u]
        for v in down_branches.get(u) or []:
            res += render_dfs(v, d + 1)
        return res

    total = []
    for r in roots:
        total += render_dfs(r, 0)
    return total


def save_ladder():
    with open(ladder_file, "w") as f:
        f.write("\n".join(render_ladder()))


def down(b, pick_mode=True):
    expect_in_ladder(b)
    dbs = down_branches.get(b)
    if not dbs or len(dbs) == 0:
        raise LadderException("Branch `%s' has no down branch" % b)
    elif len(dbs) == 1:
        return dbs[0]
    elif pick_mode:
        return pick(dbs, "down branch")
    else:
        return "\n".join(dbs)


def next_branch(b):
    expect_in_ladder(b)
    idx = all_branches.index(b) + 1
    if idx == len(all_branches):
        raise LadderException("Branch `%s' has no successor" % b)
    return all_branches[idx]


def prev_branch(b):
    expect_in_ladder(b)
    idx = all_branches.index(b) - 1
    if idx == -1:
        raise LadderException("Branch `%s' has no predecessor" % b)
    return all_branches[idx]


def root_branch(b):
    expect_in_ladder(b)
    u = up_branch.get(b)
    if not u:
        raise LadderException("Branch `%s' is already a root" % b)
    while u:
        b = u
        u = up_branch.get(b)
    return b


def up(b):
    expect_in_ladder(b)
    pb = up_branch.get(b)
    if pb:
        return pb
    else:
        raise LadderException("Branch `%s' has no up branch" % b)


def add(b):
    global roots

    if b in all_branches:
        raise LadderException("Branch `%s' already exists in the ladder" % b)

    if not sha_by_revision(b):
        raise LadderException("Branch `%s' does not exist" % b)

    onto = opt_onto
    if onto:
        expect_in_ladder(onto)
    if not roots:
        roots = [b]
        return

    if not onto:
        h = head()
        if b != h:
            onto = h
        else:
            raise LadderException("Specify the branch to add `%s' onto with `--onto'" % b)

    up_branch[b] = onto
    if onto in down_branches:
        down_branches[onto].append(b)
    else:
        down_branches[onto] = [b]
    save_ladder()


# Git/shell commands impl

def edit():
    return run_cmd(os.environ.get("EDITOR") or "vim", ladder_file)


def root_dir():
    return popen_git("rev-parse", "--show-toplevel").strip()


def sha_by_revision(rev):
    try:
        return popen_git("rev-parse", "--verify", "--quiet", rev).rstrip()
    except LadderException:
        return None


def branch_by_revision(rev):
    try:
        return popen_git("rev-parse", "--abbrev-ref", rev).strip()
    except LadderException:
        return None


def head():
    try:
        return popen_git("symbolic-ref", "--short", "--quiet", "HEAD").strip()
    except LadderException:
        raise LadderException("Not currently on any branch")


def is_ancestor(earlier, later):
    return run_git("merge-base", "--is-ancestor", earlier, later, allow_non_zero=True) == 0


def log(branch):
    return non_empty_lines(popen_git("log", "--format=%H", branch, "--"))


def reflog(b):
    # %H - full hash
    # %gs - reflog subject
    return [entry.split("|") for entry in non_empty_lines(popen_git("reflog", "--format=%H|%gs", b, "--"))]


def base(b):
    expect_in_ladder(b)
    if b not in up_branch:
        raise LadderException("Cannot find base for a root branch `%s'" % b)

    if is_ancestor(up_branch[b], b):
        return up_branch[b]

    log_this_branch = log(b)
    other_branches = excluding(branches(), [b])
    reflogs_other_branches = sum(map(reflog, other_branches), [])
    reflogs_other_branches_no_create = set(h for (h, gs) in reflogs_other_branches if not (
            (gs.startswith("branch: Created from") and not gs.startswith("branch: Created from refs/remotes/"))
            or gs.startswith("branch: Reset to " + b)))
    for h in log_this_branch:
        if h in reflogs_other_branches_no_create:
            return h
    raise LadderException("Cannot find base for branch `%s'" % b)


def branches():
    return map(lambda b: b[2:], non_empty_lines(popen_git("branch")))


def go(branch):
    run_git("checkout", "--quiet", branch, "--")


def update(branch, base_commit):
    run_git("rebase", "--interactive", "--onto", up(branch), base_commit, branch)


def squash(branch, base_commit):
    run_git("rebase", "--interactive", "--onto", base_commit, base_commit, branch)


def diff_base(branch):
    run_git("diff", *((["--stat"] if opt_stat else []) + [base(branch), "--"]))


def prune():
    to_prune = excluding(branches(), all_branches)
    if to_prune:
        bs = ", ".join(map(lambda s: "`%s'" % s, to_prune))
        msg = "This will remove the following branches: %s; continue? [y/n] " % bs
        if raw_input(msg).lower() not in ('y', 'yes'):
            return
        opt_delete = "-D" if opt_force else "-d"
        run_git("branch", opt_delete, *to_prune)
    else:
        print >> sys.stderr, "No branches to remove"


def slide_out(b):
    expect_in_ladder(b)
    u = up_branch.get(b)
    if not u:
        raise LadderException("No up-branch defined for `%s', cannot slide out" % b)
    dbs = down_branches.get(b)
    if not dbs or len(dbs) == 0:
        raise LadderException("No down-branch defined for `%s', cannot slide out" % b)
    elif len(dbs) > 1:
        flat_dbs = join_branch_names(dbs, ", ")
        raise LadderException("Multiple down-branches defined for `%s': %s; cannot slide out" % (b, flat_dbs))
    d = dbs[0]
    go(d)
    up_branch[d] = up_branch[b]
    up_branch[b] = None
    down_branches[u] = down_branches[b]
    down_branches[b] = None
    save_ladder()
    update(d, opt_down_base or base(d))
    print "Note: branch " + b + " not removed. You can now decide to remove it manually."


def check_needs_sync_with_remote(b):
    b_sha = sha_by_revision(b)
    if not b_sha:
        raise LadderException("Branch `%s' does not exist" % b)
    b_origin_sha = sha_by_revision((opt_remote or "origin") + "/" + b)
    if not b_origin_sha:
        return False
    return b_sha != b_origin_sha


def commits_between(earlier, later):
    return non_empty_lines(popen_git("log", "--format=%s", "^" + earlier, later, "--"))


def status():
    dfs_res = []

    def dfs(u, pfx):
        dfs_res.append((u, pfx))
        if down_branches.get(u):
            for (v, nv) in zip(down_branches[u][:-1], down_branches[u][1:]):
                dfs(v, pfx + [nv])
            dfs(down_branches[u][-1], pfx + [None])

    for u in roots:
        dfs(u, [])

    needs_sync_with_up_branch = {}
    needs_sync_with_remote = {}
    for b, pfx in dfs_res:
        if b in up_branch:
            needs_sync_with_up_branch[b] = not is_ancestor(up_branch[b], b)
        needs_sync_with_remote[b] = check_needs_sync_with_remote(b)

    def edge_color(b):
        return RED if needs_sync_with_up_branch[b] else GREEN

    def print_line_prefix(b, suffix):
        sys.stdout.write("  ")
        for p in pfx[:-1]:
            if not p:
                sys.stdout.write("  ")
            else:
                sys.stdout.write(edge_color(p) + "| " + ENDC)
        sys.stdout.write(edge_color(b) + suffix + ENDC)

    try:
        h = head()
    except LadderException:
        h = None

    for b, pfx in dfs_res:
        current = UNDERLINE + b + ENDC if b == h else b
        if b in up_branch:
            print_line_prefix(b, "| \n")
            if opt_list_commits:
                start = base(b) if needs_sync_with_up_branch[b] else up_branch[b]
                for msg in reversed(commits_between(start, b)):
                    print_line_prefix(b, "| " + GREY + msg + "\n")
            print_line_prefix(b, "o-")
        else:
            if b != dfs_res[0][0]:
                print
            sys.stdout.write("  ")
        print "%s%s%s%s" % (BOLD, current, ENDC, RED + " (out of sync with " + (opt_remote or "origin") + ")" + ENDC if needs_sync_with_remote[b] else "")


# Main

def usage(c=None):
    short_docs = {
        "add": "Add a branch into the ladder on the top of the current or other specified branch",
        "base": "Print SHA of the base commit of a branch",
        "diff-base": "Diff current working tree against the base commit of a branch",
        "down": "Print name(s) of the down branch(es) for a branch (aka its children in the tree)",
        "edit": "Edit the ladder definition file",
        "file": "Print path of the ladder definition file",
        "go": "Checkout the branch relative to the position in ladder, accepts down/next/root/prev/up argument",
        "help": "Print this overview, or print detailed help for a specified command",
        "next": "Print name of the next branch for a branch",
        "prev": "Print name of the previous branch for a branch",
        "prune": "Remove all local branches that are not in the ladder",
        "root": "Print name of the root branch of the tree where a branch is located",
        "slide-out": "Slide the current branch out from the ladder and rebase its down (child) branch onto its up (parent) branch",
        "squash": "Rebase the current branch onto its base commit",
        "status": "Print tree-shaped status of branches in the ladder, including info on their sync with up branch and remote",
        "up": "Print name of the up branch for a branch (aka parent in the tree)",
        "update": "Rebase the current branch onto its up (parent) branch"
    }
    long_docs = {
        "add": """
            Usage: git ladder add [-o|--onto=<target-branch>] [<branch>]

            Adds the given branch (or the current branch, if none specified) to the ladder.
            If the ladder is empty, the branch will be added as the first root of the tree.
            Otherwise, the branch will be added on the top of the current branch.
            If the current branch is the same as the branch to be added (esp. in the case when the new branch to add has not been specified at all),
            the target parent branch must be explicitly specified with `--onto' option.

            Note: the same effect can be always achieved by manually editing the ladder file.

            Options:
            -o, --onto=<target-branch>    Specifies the target parent branch to add the new branch onto.
        """,
        "base": """
            Usage: git ladder base [<branch>]

            Outputs the base commit for the given branch, or, if none specified, for the current branch.
            This is the commit that will be assumed as the default place where the history of the branch starts in the commands `diff-base', `slide-out', `squash' and most notably `update'.
            In other words, `git ladder' treats the base commit as the most recent commit in the log of the given branch that has NOT been introduced on that very branch, but on some other (usually earlier) branch.
            The branch cannot be a root of the ladder, i.e. its up (parent) branch must be defined.

            In terms of implementation, firstly `git ladder base' checks if the branch commit is a direct descendant of the up branch commit.
            If so, the up branch is simply assumed to be the base; otherwise, the following heuristics is applied.
            
            History of the given branch `x' is checked against against *adjusted reflogs* of all other local branches in the repository.
            By an adjusted reflog of a branch `y', we mean a reflog of branch `y' without any of the below operations:
            - branch creation, with exception of the creation through checkout of a remote branch
            - reset to the branch `x'
            The most recent commit in the history of the branch that appears on adjusted reflog of any other local branch will be selected as the default base commit.
            
            Note: the above definition of base commit returns a correct result in most cases, but there are some situations (esp. when some local branches have already been deleted) where base commit might be determined wrongly.
            Thus, all rebase-involving operations (`slide-out', `squash' and `update') run `git rebase' in the interactive mode and allow to specify the base commit explictly by a command-line option.
        """,
        "diff-base": """
            Usage: git ladder diff-base [-b | --base=<base-commit>] [-s | --stat] [<branch>]

            Runs `git diff' of the the current working directory against the base commit of the given branch or, if none specified, of the current branch.
            See `git ladder help base' for more details on meaning of the `base commit'.

            Options:
            -s, --stat    Makes diff-base pass `--stat' option to `git diff', so that only summary (diffstat) will be output.
        """,
        "down":  """
            Usage: git ladder down [<branch>]

            Outputs name of the branch (or branches, if many) that are direct children of the given branch (or current branch, if none specified) in the ladder.
        """,
        "edit": """
            Usage: git ladder e[dit]

            Opens the editor (as defined by the `EDITOR' environment variable, or `vim' if undefined) and lets you edit the ladder definition file manually.
            The ladder file can be always accessed under path returned by `git ladder file' (currently fixed to <repo-root>/.git/ladder).
        """,
        "file": """
            Usage: git ladder file

            Outputs the path of the ladder definition file (currently fixed to <repo-root>/.git/ladder).
        """,
        "go": """
            Usage: git ladder g[o] <direction>
            where <direction> is one of: d[own], n[ext], p[rev], r[oot], u[p]

            Checks out the branch of the ladder specified by the given direction.
            Roughly equivalent to `git checkout $(git ladder <direction>)'.
        """,
        "help": """
            Usage: git ladder help [<command>]

            Prints a summary of this tool, or a detailed info on a command if defined.
        """,
        "next": """
            Usage: git ladder next [<branch>]

            Outputs name of the branch that directly follows the given branch (or current branch, if none specified) in the ladder file.
        """,
        "prev": """
            Usage: git ladder prev [<branch>]

            Outputs name of the branch that directly precedes the given branch (or current branch, if none specified) in the ladder file.
        """,
        "prune": """
            Usage: git ladder prune [-f|--force]

            Lists the local git branches that don't exist in the ladder, and removes all of them by `git branch -d' if confirmed by the user.

            Note: this should be used with care since removing local branches can sometimes make it impossible for git ladder to properly compute base commits.
            See `git ladder help base' for more details.

            Options:
            -f, --force    Passes `-D' instead of `-d' to `git branch'; this will delete branches even if they are not merged yet.
        """,
        "root": """
            Usage: git ladder root [<branch>]

            Outputs name of the branch that is the root of the tree where the given branch (or current branch, if none specified) is located in the ladder.
            Depending on your case, this will typically be something like `develop' or `master', since all branches are usually meant to be ultimately merged to one of those.
        """,
        "slide-out": """
            Usage: git ladder slide-out [-d|--down-base=<down-base-commit>] [<branch>]

            Removes the current branch from the ladder and rebases the down (child) branch of the current branch on the top of the up (parent) branch of the current branch.

            Note: slide-out will return an error if the current branch has no down branches, more than one down branch, or is a root (has no up branch).
            In other words, slide-out works only when the branch has exactly one up branch and exactly one down branch.

            -d, --down-base=<down-base-commit>    Specifies the alternative base commit after which the rebased part of history of the down branch should start.
                                                  See also doc for `--base' option for `git ladder help squash' and `git ladder help update'.
        """,
        "squash": """
            Usage: git ladder squash [-b|--base=<base-commit>]

            Interactively rebase the current branch on the top of its base commit.
            This is useful e.g. for squashing the commits on the current branch to make history more condensed before push to the remote.
            The chunk of the history to be rebased starts at the base commit of the current branch by default, but can also be set explicitly by `--base'.

            Options:
            -b, --base=<base-commit>    Specifies the alternative base commit after which the rebased part of history should start.
        """,
        "status": """
            Usage: git ladder s[tatus] [-r|--remote=<remote-name>]

            Outputs a tree-shaped status of the branches in the ladder.

            Apart from simply ASCII-formatting the tree defined in the ladder definition file, this also:
            * prints `(out of sync with <remote>)' message for each branch that differs from its remote counterpart (in the `origin' remote by default),
            * colors the edges between up (parent) and down (child) branches depending on whether down branch commit is a direct descendant of the up branch commit:
              - green edge means that the down branch commit is direct descendant of the up branch commit (basically, the down branch is in sync with its up branch),
              - red edge means the opposite (so the down branch is out of sync).

            Options:
            -r, --remote=<remote-name>    Specifies the alternative name of the remote (if different from the default `origin').
        """,
        "up": """
            Usage: git ladder up [<branch>]

            Outputs name of the branch that is the direct parent of the given branch (or current branch, if none specified) in the ladder.
        """,
        "update": """
            Usage: git ladder update [-b|--base=<base-commit>]

            Interactively rebase the current branch on the top of its up (parent) branch in the ladder.
            This is useful e.g. for syncing the current branch with changes introduced by an upstream branch like `develop', or changes commited on the parent branches.
            The chunk of the history to be rebased starts at the base commit of the current branch by default, but can also be set explicitly by `--base'.

            Options:
            -b, --base=<base-commit>    Specifies the alternative base commit after which the rebased part of history should start.
        """
    }
    aliases = {
        "edit": "e",
        "go": "g",
        "status": "s"
    }
    groups = [
        ("General commands", ["help"]),
        ("Modify and display the ladder", ["add", "edit", "file", "status"]),
        ("Move across the ladder", ["down", "go", "next", "prev", "root", "up"]),
        ("Determine changes introduced on the branch", ["base", "diff-base"]),
        ("Update history in accordance with the ladder", ["slide-out", "squash", "update"]),
        ("Tidy up git branches", ["prune"])
    ]
    if c and c in short_docs:
        print >> sys.stderr, textwrap.dedent(long_docs[c])
    else:
        short_usage()
        if c and c not in short_docs:
            print >> sys.stderr, "\nUnknown command: `%s'" % c
        print >> sys.stderr, "\n" + UNDERLINE + "TL;DR tip" + ENDC + ": get familiar with `edit', `status' and `update' commands.\n"
        for hdr, cmds in groups:
            print >> sys.stderr, BOLD + hdr + ENDC + "\n"
            for cm in cmds:
                alias = (", " + aliases[cm]) if cm in aliases else ""
                print >> sys.stderr, "    %s%-14s%s%s" % (BOLD, cm + alias, ENDC, short_docs[cm])
            print >> sys.stderr


def short_usage():
    print >> sys.stderr, "Usage: git ladder [--help] [--verbose] <command> [command-specific options] [command-specific argument]"


def parse_options(in_args, short_opts="", long_opts=[], gnu=True):
    global cmd, opt_base, opt_down_base, opt_force, opt_list_commits, opt_onto, opt_remote, opt_stat, opt_verbose

    fun = getopt.gnu_getopt if gnu else getopt.getopt
    opts, rest = fun(in_args, short_opts + "hv", long_opts + ['help', 'verbose'])

    for opt, arg in opts:
        if opt in ("-b", "--base"):
            opt_base = arg
        elif opt in ("-d", "--down-base"):
            opt_down_base = arg
        elif opt in ("-f", "--force"):
            opt_force = True
        elif opt in ("-h", "--help"):
            usage(cmd)
            sys.exit()
        elif opt in ("-l", "--list-commits"):
            opt_list_commits = True
        elif opt in ("-o", "--onto"):
            opt_onto = arg
        elif opt in ("-r", "--remote"):
            opt_remote = arg
        elif opt in ("-s", "--stat"):
            opt_stat = True
        elif opt in ("-v", "--verbose"):
            opt_verbose = True
    return rest


def expect_no_param(in_args, extra_explanation = ''):
    if len(in_args) == 2:
        raise LadderException("No argument expected for `%s'%s" % (cmd, extra_explanation))


def check_optional_param(in_args):
    if not in_args:
        return None
    elif len(in_args) > 1:
        raise LadderException("`%s' accepts at most one argument" % cmd)
    elif not in_args[0]:
        raise LadderException("Argument to `%s' cannot be empty" % cmd)
    elif in_args[0][0] == "-":
        raise LadderException("option `%s' not recognized" % in_args[0])
    else:
        return in_args[0]


def check_required_param(in_args):
    if not in_args or len(in_args) > 1:
        raise LadderException("`%s' requires exactly one argument" % cmd)
    elif not in_args[0]:
        raise LadderException("Argument to `%s' cannot be empty" % cmd)
    elif in_args[0][0] == "-":
        raise LadderException("option `%s' not recognized" % in_args[0])
    else:
        return in_args[0]


try:
    cmd = None
    opt_base = None
    opt_down_base = None
    opt_force = False
    opt_list_commits = False
    opt_onto = None
    opt_remote = None
    opt_stat = False
    opt_verbose = False

    all_args = parse_options(sys.argv[1:], gnu=False)
    if not all_args:
        usage()
        sys.exit(2)
    cmd = all_args[0]
    args = all_args[1:]

    try:
        git_root = root_dir()
    except LadderException:
        raise LadderException("Not a git repository")

    ladder_file = os.path.join(git_root, ".git", "ladder")
    if not os.path.exists(ladder_file):
        open(ladder_file, 'w').close()

    if cmd not in ("e", "edit", "file", "help"):
        read_ladder()

    if cmd == "add":
        param = check_optional_param(parse_options(args, "o:", ["onto="]))
        add(param or head())
    elif cmd == "base":
        param = check_optional_param(parse_options(args))
        print base(param or head())
    elif cmd in ("db", "diff-base"):
        param = check_optional_param(parse_options(args, "s", ["stat"]))
        diff_base(param or head())
    elif cmd == "down":
        param = check_optional_param(parse_options(args))
        print down(param or head(), pick_mode=False)
    elif cmd in ("e", "edit"):
        expect_no_param(parse_options(args))
        edit()
    elif cmd == "file":
        expect_no_param(parse_options(args))
        print ladder_file
    elif cmd in ("g", "go"):
        param = check_required_param(parse_options(args))
        h = head()
        if param in ("d", "down"):
            dest = down(h)
        elif param in ("n", "next"):
            dest = next_branch(h)
        elif param in ("p", "prev"):
            dest = prev_branch(h)
        elif param in ("r", "root"):
            dest = root_branch(h)
        elif param in ("u", "up"):
            dest = up(h)
        else:
            raise LadderException("Usage: git ladder go <d[own]|n[ext]|p[rev]|r[oot]|u[p]>")
        if dest != h:
            go(dest)
    elif cmd == "help":
        param = check_optional_param(parse_options(args))
        usage(param)
    elif cmd == "next":
        param = check_optional_param(parse_options(args))
        print next_branch(param or head())
    elif cmd == "prev":
        param = check_optional_param(parse_options(args))
        print prev_branch(param or head())
    elif cmd == "prune":
        expect_no_param(parse_options(args, "f", ["force"]))
        prune()
    elif cmd == "root":
        param = check_optional_param(parse_options(args))
        print root_branch(param or head())
    elif cmd == "slide-out":
        param = check_optional_param(parse_options(args, "d:", ["down-base="]))
        slide_out(param or head())
    elif cmd == "squash":
        args1 = parse_options(args, "b:", ["base="])
        expect_no_param(args1, ". Use `-b' or `--base' to specify the base commit")
        h = head()
        squash(h, opt_base or base(h))
    elif cmd in ("s", "status"):
        expect_no_param(parse_options(args, "lr:", ["list-commits", "remote="]))
        status()
    elif cmd == "up":
        param = check_optional_param(parse_options(args))
        print up(param or head())
    elif cmd == "update":
        args1 = parse_options(args, "b:", ["base="])
        expect_no_param(args1, ". Use `-b' or `--base' to specify the base commit")
        h = head()
        update(h, opt_base or base(h))
    else:
        short_usage()
        raise LadderException("\nUnknown command: `%s'. Use `git ladder help' to list possible commands" % cmd)

except LadderException as e:
    print >> sys.stderr, str(e)
    sys.exit(1)
except getopt.GetoptError as e:
    short_usage()
    print >> sys.stderr, str(e)
    sys.exit(2)
