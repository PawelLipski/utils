#!/usr/bin/env python

import os
import subprocess
import sys

ladder_file = ".git/ladder"

# Core utils

def non_empty_lines(s):
    return filter(None, s.split("\n"))


def excluding(l, s):
    return filter(lambda x: x not in s, l)


def run_cmd(cmd, *args):
    return subprocess.call([cmd] + list(args)) == 0


def popen_cmd(cmd, *args):
    return subprocess.Popen([cmd] + list(args), stdout=subprocess.PIPE).stdout.read()


# Git core

def run_git(git_cmd, *args):
    print " ".join(["git", git_cmd] + list(args))
    return run_cmd("git", git_cmd, *args)


def popen_git(git_cmd, *args):
    print " ".join(["git", git_cmd] + list(args))
    return popen_cmd("git", git_cmd, *args)


# Ladder manipulation

def read_ladder():
    with open(ladder_file, "r") as f:
        return map(lambda l: l.strip(), f.readlines())


def save_ladder(ladder):
    with open(ladder_file, "w") as f:
        f.write("\n".join(ladder))


def shift(branch, offset):
    ladder = read_ladder()
    idx = ladder.index(branch)
    new_idx = min(max(0, idx + offset), len(ladder) - 1)
    return ladder[new_idx]


def down(branch):
    return shift(branch, 1)


def up(branch):
    return shift(branch, -1)


def push(branch):
    ladder = read_ladder()
    save_ladder([branch] + ladder)


# Git/shell commands impl

def edit():
    return run_cmd(os.environ.get("EDITOR") or "vim", ladder_file)


def head():
    return popen_git("symbolic-ref", "--short", "--quiet", "HEAD").strip()


def log(branch):
    return non_empty_lines(popen_git("log", "--format=%H", branch, "--"))


def reflog(bs):
    # %H - full hash
    # %gs - reflog subject
    return [entry.split("|") for entry in non_empty_lines(popen_git("reflog", "--format=%H|%gs", *(bs + ["--"])))]


def base(branch):
    log_this_branch = log(branch)
    other_branches = excluding(branches(), [branch])
    reflogs_other_branches = reflog(other_branches)
    reflogs_other_branches_no_create = set(h for (h, gs) in reflogs_other_branches if not (
                gs.startswith("branch: Created") or gs.startswith("branch: Reset to " + branch)))
    for h in log_this_branch:
        if h in reflogs_other_branches_no_create:
            return h
    # TODO: handle that somehow...
    return "0" * 32


def branches():
    return map(lambda b: b[2:], non_empty_lines(popen_git("branch")))


def go(branch):
    # TODO: don't go to current branch....
    return run_git("checkout", "--quiet", branch, "--")


def rebase(branch, base_commit):
    return run_git("rebase", "--interactive", "--onto", down(branch), base_commit, branch)


def diff_base(branch):
    return run_git("diff", base(branch), branch, "--")


def prune():
    # TODO: ask to confirm + also mention about `rebase` possibly not working
    return run_git("branch", "-d", *excluding(branches(), read_ladder()))


# Main

def main():
    # TODO validate if present
    cmd = sys.argv[1]
    if cmd == "base":
        # TODO: or sth else if param provided
        print base(head())
    elif cmd == "diff-base":
        diff_base(head())
    elif cmd == "down":
        # TODO: or sth else if param provided
        print shift(head(), 1)
    elif cmd == "edit":
        edit()
    elif cmd == "go":
        # TODO validate if present
        direction = sys.argv[2]
        if direction == "down":
            go(down(head()))
        elif direction == "up":
            go(up(head()))
        else:
            print "Wrong direction"
    elif cmd == "list":
        print "\n".join(read_ladder())
    elif cmd == "prune":
        # TODO: -f option that would call branch -D
        prune()
    elif cmd == "push":
        # TODO: or sth else if param provided
        push(head())
    elif cmd == "rebase":
        # TODO: parse -b option (or maybe call it differently, like -a for after?)
        h = head()
        b = sys.argv[2] if len(sys.argv) >= 3 else base(h)
        rebase(h, b)
    elif cmd == "slide-out":
        # TODO: or sth else if param provided
        h = head()
        u = up(h)
        go(u)
        ladder = read_ladder()
        save_ladder(excluding(ladder, [h]))
        rebase(u, base(u))
        print "Note: branch " + h + " not removed. You can now decide to remove it manually."
    elif cmd == "up":
        # TODO: or sth else if param provided
        print shift(head(), -1)
    elif cmd == "update":
        h = head()
        b = sys.argv[2] if len(sys.argv) >= 3 else base(h)
        rebase(h, b) and run_git("push", "--force") and go(up(h))
    else:
        # TODO exit() or stuff
        print "Unknown command"


if __name__ == '__main__':
    main()
